# Python Script to Extract Transitive Dependencies from a .NET Project

Here's a Python script that can analyze a .NET project file (.csproj) or solution file (.sln) to extract transitive dependencies:

```python
import os
import xml.etree.ElementTree as ET
from collections import defaultdict
import subprocess

def get_dotnet_version():
    try:
        result = subprocess.run(['dotnet', '--version'], capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        print("Error: .NET SDK not found. Please ensure .NET SDK is installed.")
        exit(1)

def analyze_project_file(project_path):
    """Analyze a single .csproj file and return its direct dependencies"""
    tree = ET.parse(project_path)
    root = tree.getroot()
    
    ns = {'msbuild': 'http://schemas.microsoft.com/developer/msbuild/2003'}
    dependencies = []
    
    # Find PackageReference items
    for item in root.findall(".//PackageReference"):
        package_name = item.attrib.get('Include')
        package_version = item.attrib.get('Version')
        if package_name:
            dependencies.append((package_name, package_version or 'N/A'))
    
    # For newer SDK-style projects
    for item in root.findall(".//PackageReference"):
        package_name = item.attrib.get('Include')
        package_version = item.attrib.get('Version')
        if package_name:
            dependencies.append((package_name, package_version or 'N/A'))
    
    return dependencies

def get_transitive_dependencies(project_path):
    """Use dotnet CLI to get transitive dependencies"""
    try:
        cmd = ['dotnet', 'list', project_path, 'package', '--include-transitive']
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        return parse_dotnet_list_output(result.stdout)
    except subprocess.CalledProcessError as e:
        print(f"Error running dotnet list command: {e.stderr}")
        return []

def parse_dotnet_list_output(output):
    """Parse the output of 'dotnet list package --include-transitive' command"""
    lines = output.split('\n')
    dependencies = []
    capture = False
    
    for line in lines:
        if line.strip().startswith('>'):
            capture = True
            continue
        if capture and line.strip() and not line.strip().startswith('Top-level Package'):
            parts = [p.strip() for p in line.split(' ') if p.strip()]
            if len(parts) >= 2:
                package = parts[0]
                version = parts[1]
                is_transitive = '(D)' not in line
                dependencies.append((package, version, is_transitive))
    
    return dependencies

def find_project_files(solution_path):
    """Find all .csproj files in a solution or directory"""
    if solution_path.endswith('.sln'):
        # Parse solution file to find projects
        project_files = []
        with open(solution_path, 'r') as f:
            for line in f:
                if line.strip().startswith('Project('):
                    parts = line.split(',')
                    if len(parts) >= 2:
                        project_path = parts[1].strip().strip('"')
                        if project_path.endswith('.csproj'):
                            # Handle relative paths
                            base_dir = os.path.dirname(solution_path)
                            full_path = os.path.join(base_dir, project_path)
                            project_files.append(full_path)
        return project_files
    elif solution_path.endswith('.csproj'):
        return [solution_path]
    else:
        # Search directory for all .csproj files
        project_files = []
        for root, _, files in os.walk(solution_path):
            for file in files:
                if file.endswith('.csproj'):
                    project_files.append(os.path.join(root, file))
        return project_files

def generate_dependency_report(projects):
    """Generate a report of all dependencies"""
    report = defaultdict(list)
    
    for project_path, dependencies in projects.items():
        for package, version, is_transitive in dependencies:
            report[(package, version)].append((project_path, is_transitive))
    
    print("\nDependency Report:")
    print("=" * 80)
    for (package, version), projects in sorted(report.items()):
        transitive_count = sum(1 for _, is_trans in projects if is_trans)
        direct_count = len(projects) - transitive_count
        
        print(f"\nPackage: {package} ({version})")
        print(f"  Total projects: {len(projects)} (Direct: {direct_count}, Transitive: {transitive_count})")
        
        for project, is_trans in projects:
            print(f"  - {'[Transitive]' if is_trans else '[Direct]'} {os.path.basename(project)}")

def main():
    print(f".NET SDK Version: {get_dotnet_version()}")
    
    path = input("Enter path to .sln or .csproj file or directory: ").strip()
    if not os.path.exists(path):
        print("Error: Path does not exist")
        return
    
    project_files = find_project_files(path)
    if not project_files:
        print("No .csproj files found")
        return
    
    print(f"\nFound {len(project_files)} project(s):")
    for pf in project_files:
        print(f" - {pf}")
    
    all_dependencies = {}
    
    for project_file in project_files:
        print(f"\nAnalyzing {os.path.basename(project_file)}...")
        dependencies = get_transitive_dependencies(project_file)
        all_dependencies[project_file] = dependencies
        
        print(f"Found {len(dependencies)} dependencies:")
        for dep in dependencies[:10]:  # Show first 10 to avoid flooding
            print(f" - {dep[0]} {dep[1]} {'(Transitive)' if dep[2] else ''}")
        if len(dependencies) > 10:
            print(f" - ... and {len(dependencies) - 10} more")
    
    generate_dependency_report(all_dependencies)

if __name__ == "__main__":
    main()
```

## How to Use This Script

1. Save this script as `dotnet_dependency_analyzer.py`
2. Make sure you have Python installed (3.6 or higher)
3. Ensure the .NET SDK is installed and available in your PATH
4. Run the script with: `python dotnet_dependency_analyzer.py`
5. Enter the path to your .sln file, .csproj file, or directory containing projects

## Features

- Detects both direct and transitive dependencies
- Works with both traditional and SDK-style .NET projects
- Provides a summary report showing which packages are used where
- Distinguishes between direct and transitive dependencies
- Handles solution files and multiple projects

## Limitations

- Requires .NET SDK to be installed for accurate transitive dependency detection
- May not handle all project file edge cases (custom imports, etc.)
- For very large solutions, the output might be verbose

You can modify the script to output the results in different formats (JSON, CSV) or filter the results as needed.